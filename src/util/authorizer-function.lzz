class Authorizerfunction {
public:
    explicit Authorizerfunction(v8::Isolate* _isolate, v8::Local<v8::Function> _fn)
        : isolate(_isolate), fn(_isolate, _fn) { }

    static int xAuth(void* p, int op, const char* a0, const char* a1, const char* database, const char* trigger) {
        Authorizerfunction* self = static_cast<Authorizerfunction*>(p);
	    v8::Isolate* isolate = self->isolate;
        v8::HandleScope scope(isolate);

        v8::Local<v8::Value> args[5];
        args[0] = v8::Integer::New(isolate, op);
        args[1] = a0?       StringFromUtf8(isolate, a0, -1) : v8::String::Empty(isolate);
        args[2] = a1?       StringFromUtf8(isolate, a1, -1) : v8::String::Empty(isolate);
        args[3] = database? StringFromUtf8(isolate, database, -1) : v8::String::Empty(isolate);
        args[4] = trigger?  StringFromUtf8(isolate, trigger, -1) : v8::String::Empty(isolate);

        v8::MaybeLocal<v8::Value> maybe_return_value = v8::Local<v8::Function>::New(isolate, self->fn)->Call(OnlyContext, v8::Undefined(isolate), 5, args);
        if(!maybe_return_value.IsEmpty()) {
            v8::Local<v8::Value> value = maybe_return_value.ToLocalChecked();
            if(value->IsNumber()) {
                return v8::Local<v8::Number>::Cast(value)->Value();
            }
        }

        return SQLITE_ERROR;
    }

protected:
    v8::Isolate* const isolate;
	const CopyablePersistent<v8::Function> fn;
};